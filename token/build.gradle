buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:1.5.4.RELEASE")
    }
}

repositories {
    jcenter()
    maven { url "http://maven.aliyun.com/nexus/content/groups/public/" }
    maven { url "http://repo.maven.apache.org/maven2" }
}

apply plugin: 'org.springframework.boot'
apply plugin: 'java'
apply plugin: 'maven'

group 'org.web3j'
version '3.3.1'


sourceCompatibility = 1.8
targetCompatibility = 1.8

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

jar {
    manifest {  //incubating版本，以后版本可能会改API
        attributes("Main-Class": "com.blockchain.Main",
                "Implementation-Title": "Gradle"
//                "Class-Path": configurations.compile.collect { it.absolutePath }.join(" ")
        )
    }

    //会在生成的jar包中，把所有的依赖再次打包，而这个包是多余的，因为上面那条配置就已经打包好了所有的依赖包
//    into('lib') {
//        from configurations.runtime
//    }
}


sourceSets {
    main {
        //output.resourcesDir default is  'build/resources/main'
        //output.classesDir default is  'build/classes/main'
        //合并 classes 和 resources的输出路径，方便 直接执行 main方法时，在当前classpath下能找到 resources里的配置文件
        output.resourcesDir = 'build/classes/main'
        output.classesDir   = 'build/classes/main'
    }
}

configurations {
    deployerJars
}

//https://stackoverflow.com/questions/36923288/how-to-run-bootrun-with-spring-profile-via-gradle-task
//def profiles = 'dev'
//bootRun {
//    args = ["--spring.profiles.active=" + profiles]
//}

task pro << {
    bootRun.systemProperty 'spring.profiles.active', 'pro'
}

task dev << {
    bootRun.systemProperty 'spring.profiles.active', 'dev'
}

sourceCompatibility = 1.8

repositories {
    mavenCentral()
}

dependencies {
    testCompile group: 'junit', name: 'junit', version: '4.12'
    compile project(':core')
    compile project(':geth')
}
